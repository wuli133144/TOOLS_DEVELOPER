// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.RPC.proto

#ifndef PROTOBUF_IM_2eRPC_2eproto__INCLUDED
#define PROTOBUF_IM_2eRPC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace RPC {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eRPC_2eproto();
void protobuf_AssignDesc_IM_2eRPC_2eproto();
void protobuf_ShutdownFile_IM_2eRPC_2eproto();

class TarsInfo;
class GroupIDName;
class CourseGroupInfo;
class GroupMsgId;
class GroupMsgRes;
class IMRPCGetCourseGroupInfoReq;
class IMRPCGetCourseGroupInfoRsp;
class IMRPCSendGroupMsgReq;
class IMRPCSendGroupMsgRsp;
class IMRPCDeleteGroupMsgReq;
class IMRPCDeleteGroupMsgRsp;

// ===================================================================

class TarsInfo : public ::google::protobuf::MessageLite {
 public:
  TarsInfo();
  virtual ~TarsInfo();

  TarsInfo(const TarsInfo& from);

  inline TarsInfo& operator=(const TarsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TarsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TarsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TarsInfo* other);

  // implements Message ----------------------------------------------

  TarsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TarsInfo& from);
  void MergeFrom(const TarsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 fd = 1;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 1;
  inline ::google::protobuf::uint32 fd() const;
  inline void set_fd(::google::protobuf::uint32 value);

  // required uint32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 request_id = 3;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);

  // required uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:IM.RPC.TarsInfo)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fd_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 request_id_;
  ::google::protobuf::uint32 port_;
  ::std::string* ip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static TarsInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupIDName : public ::google::protobuf::MessageLite {
 public:
  GroupIDName();
  virtual ~GroupIDName();

  GroupIDName(const GroupIDName& from);

  inline GroupIDName& operator=(const GroupIDName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupIDName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupIDName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupIDName* other);

  // implements Message ----------------------------------------------

  GroupIDName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupIDName& from);
  void MergeFrom(const GroupIDName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required string group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // @@protoc_insertion_point(class_scope:IM.RPC.GroupIDName)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* group_name_;
  ::google::protobuf::uint32 group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static GroupIDName* default_instance_;
};
// -------------------------------------------------------------------

class CourseGroupInfo : public ::google::protobuf::MessageLite {
 public:
  CourseGroupInfo();
  virtual ~CourseGroupInfo();

  CourseGroupInfo(const CourseGroupInfo& from);

  inline CourseGroupInfo& operator=(const CourseGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CourseGroupInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CourseGroupInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CourseGroupInfo* other);

  // implements Message ----------------------------------------------

  CourseGroupInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CourseGroupInfo& from);
  void MergeFrom(const CourseGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required string group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string creator_name = 3;
  inline bool has_creator_name() const;
  inline void clear_creator_name();
  static const int kCreatorNameFieldNumber = 3;
  inline const ::std::string& creator_name() const;
  inline void set_creator_name(const ::std::string& value);
  inline void set_creator_name(const char* value);
  inline void set_creator_name(const char* value, size_t size);
  inline ::std::string* mutable_creator_name();
  inline ::std::string* release_creator_name();
  inline void set_allocated_creator_name(::std::string* creator_name);

  // required uint32 identity = 4;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 4;
  inline ::google::protobuf::uint32 identity() const;
  inline void set_identity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.RPC.CourseGroupInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_creator_name();
  inline void clear_has_creator_name();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* group_name_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 identity_;
  ::std::string* creator_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static CourseGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgId : public ::google::protobuf::MessageLite {
 public:
  GroupMsgId();
  virtual ~GroupMsgId();

  GroupMsgId(const GroupMsgId& from);

  inline GroupMsgId& operator=(const GroupMsgId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupMsgId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMsgId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMsgId* other);

  // implements Message ----------------------------------------------

  GroupMsgId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMsgId& from);
  void MergeFrom(const GroupMsgId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.RPC.GroupMsgId)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 msg_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgId* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgRes : public ::google::protobuf::MessageLite {
 public:
  GroupMsgRes();
  virtual ~GroupMsgRes();

  GroupMsgRes(const GroupMsgRes& from);

  inline GroupMsgRes& operator=(const GroupMsgRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupMsgRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMsgRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMsgRes* other);

  // implements Message ----------------------------------------------

  GroupMsgRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMsgRes& from);
  void MergeFrom(const GroupMsgRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.RPC.GroupMsgRes)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgRes* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCGetCourseGroupInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMRPCGetCourseGroupInfoReq();
  virtual ~IMRPCGetCourseGroupInfoReq();

  IMRPCGetCourseGroupInfoReq(const IMRPCGetCourseGroupInfoReq& from);

  inline IMRPCGetCourseGroupInfoReq& operator=(const IMRPCGetCourseGroupInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCGetCourseGroupInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCGetCourseGroupInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCGetCourseGroupInfoReq* other);

  // implements Message ----------------------------------------------

  IMRPCGetCourseGroupInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCGetCourseGroupInfoReq& from);
  void MergeFrom(const IMRPCGetCourseGroupInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required .IM.RPC.TarsInfo tars_info = 2;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 2;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCGetCourseGroupInfoReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_im_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCGetCourseGroupInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCGetCourseGroupInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMRPCGetCourseGroupInfoRsp();
  virtual ~IMRPCGetCourseGroupInfoRsp();

  IMRPCGetCourseGroupInfoRsp(const IMRPCGetCourseGroupInfoRsp& from);

  inline IMRPCGetCourseGroupInfoRsp& operator=(const IMRPCGetCourseGroupInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCGetCourseGroupInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCGetCourseGroupInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCGetCourseGroupInfoRsp* other);

  // implements Message ----------------------------------------------

  IMRPCGetCourseGroupInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCGetCourseGroupInfoRsp& from);
  void MergeFrom(const IMRPCGetCourseGroupInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // repeated .IM.RPC.CourseGroupInfo group_info_list = 2;
  inline int group_info_list_size() const;
  inline void clear_group_info_list();
  static const int kGroupInfoListFieldNumber = 2;
  inline const ::IM::RPC::CourseGroupInfo& group_info_list(int index) const;
  inline ::IM::RPC::CourseGroupInfo* mutable_group_info_list(int index);
  inline ::IM::RPC::CourseGroupInfo* add_group_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::CourseGroupInfo >&
      group_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::CourseGroupInfo >*
      mutable_group_info_list();

  // required .IM.RPC.TarsInfo tars_info = 3;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 3;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCGetCourseGroupInfoRsp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::RPC::CourseGroupInfo > group_info_list_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 result_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCGetCourseGroupInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCSendGroupMsgReq : public ::google::protobuf::MessageLite {
 public:
  IMRPCSendGroupMsgReq();
  virtual ~IMRPCSendGroupMsgReq();

  IMRPCSendGroupMsgReq(const IMRPCSendGroupMsgReq& from);

  inline IMRPCSendGroupMsgReq& operator=(const IMRPCSendGroupMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCSendGroupMsgReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCSendGroupMsgReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCSendGroupMsgReq* other);

  // implements Message ----------------------------------------------

  IMRPCSendGroupMsgReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCSendGroupMsgReq& from);
  void MergeFrom(const IMRPCSendGroupMsgReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_portrait = 4;
  inline bool has_user_portrait() const;
  inline void clear_user_portrait();
  static const int kUserPortraitFieldNumber = 4;
  inline const ::std::string& user_portrait() const;
  inline void set_user_portrait(const ::std::string& value);
  inline void set_user_portrait(const char* value);
  inline void set_user_portrait(const char* value, size_t size);
  inline ::std::string* mutable_user_portrait();
  inline ::std::string* release_user_portrait();
  inline void set_allocated_user_portrait(::std::string* user_portrait);

  // required uint32 msg_type = 5;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 msg_type() const;
  inline void set_msg_type(::google::protobuf::uint32 value);

  // required bytes msg_data = 6;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 6;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // repeated uint32 group_id_list = 7;
  inline int group_id_list_size() const;
  inline void clear_group_id_list();
  static const int kGroupIdListFieldNumber = 7;
  inline ::google::protobuf::uint32 group_id_list(int index) const;
  inline void set_group_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_group_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      group_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_group_id_list();

  // required .IM.RPC.TarsInfo tars_info = 8;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 8;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCSendGroupMsgReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_portrait();
  inline void clear_has_user_portrait();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* user_name_;
  ::std::string* user_portrait_;
  ::std::string* msg_data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > group_id_list_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 msg_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCSendGroupMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCSendGroupMsgRsp : public ::google::protobuf::MessageLite {
 public:
  IMRPCSendGroupMsgRsp();
  virtual ~IMRPCSendGroupMsgRsp();

  IMRPCSendGroupMsgRsp(const IMRPCSendGroupMsgRsp& from);

  inline IMRPCSendGroupMsgRsp& operator=(const IMRPCSendGroupMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCSendGroupMsgRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCSendGroupMsgRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCSendGroupMsgRsp* other);

  // implements Message ----------------------------------------------

  IMRPCSendGroupMsgRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCSendGroupMsgRsp& from);
  void MergeFrom(const IMRPCSendGroupMsgRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  inline int group_msg_res_list_size() const;
  inline void clear_group_msg_res_list();
  static const int kGroupMsgResListFieldNumber = 2;
  inline const ::IM::RPC::GroupMsgRes& group_msg_res_list(int index) const;
  inline ::IM::RPC::GroupMsgRes* mutable_group_msg_res_list(int index);
  inline ::IM::RPC::GroupMsgRes* add_group_msg_res_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
      group_msg_res_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
      mutable_group_msg_res_list();

  // required .IM.RPC.TarsInfo tars_info = 3;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 3;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCSendGroupMsgRsp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes > group_msg_res_list_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 result_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCSendGroupMsgRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCDeleteGroupMsgReq : public ::google::protobuf::MessageLite {
 public:
  IMRPCDeleteGroupMsgReq();
  virtual ~IMRPCDeleteGroupMsgReq();

  IMRPCDeleteGroupMsgReq(const IMRPCDeleteGroupMsgReq& from);

  inline IMRPCDeleteGroupMsgReq& operator=(const IMRPCDeleteGroupMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCDeleteGroupMsgReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCDeleteGroupMsgReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCDeleteGroupMsgReq* other);

  // implements Message ----------------------------------------------

  IMRPCDeleteGroupMsgReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCDeleteGroupMsgReq& from);
  void MergeFrom(const IMRPCDeleteGroupMsgReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // repeated .IM.RPC.GroupMsgId group_msg_id_list = 2;
  inline int group_msg_id_list_size() const;
  inline void clear_group_msg_id_list();
  static const int kGroupMsgIdListFieldNumber = 2;
  inline const ::IM::RPC::GroupMsgId& group_msg_id_list(int index) const;
  inline ::IM::RPC::GroupMsgId* mutable_group_msg_id_list(int index);
  inline ::IM::RPC::GroupMsgId* add_group_msg_id_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgId >&
      group_msg_id_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgId >*
      mutable_group_msg_id_list();

  // required .IM.RPC.TarsInfo tars_info = 3;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 3;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCDeleteGroupMsgReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgId > group_msg_id_list_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_im_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCDeleteGroupMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCDeleteGroupMsgRsp : public ::google::protobuf::MessageLite {
 public:
  IMRPCDeleteGroupMsgRsp();
  virtual ~IMRPCDeleteGroupMsgRsp();

  IMRPCDeleteGroupMsgRsp(const IMRPCDeleteGroupMsgRsp& from);

  inline IMRPCDeleteGroupMsgRsp& operator=(const IMRPCDeleteGroupMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCDeleteGroupMsgRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCDeleteGroupMsgRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCDeleteGroupMsgRsp* other);

  // implements Message ----------------------------------------------

  IMRPCDeleteGroupMsgRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCDeleteGroupMsgRsp& from);
  void MergeFrom(const IMRPCDeleteGroupMsgRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  inline int group_msg_res_list_size() const;
  inline void clear_group_msg_res_list();
  static const int kGroupMsgResListFieldNumber = 2;
  inline const ::IM::RPC::GroupMsgRes& group_msg_res_list(int index) const;
  inline ::IM::RPC::GroupMsgRes* mutable_group_msg_res_list(int index);
  inline ::IM::RPC::GroupMsgRes* add_group_msg_res_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
      group_msg_res_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
      mutable_group_msg_res_list();

  // required .IM.RPC.TarsInfo tars_info = 3;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 3;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.RPC.IMRPCDeleteGroupMsgRsp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes > group_msg_res_list_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 result_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRPC_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRPC_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRPC_2eproto();

  void InitAsDefaultInstance();
  static IMRPCDeleteGroupMsgRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// TarsInfo

// required uint32 fd = 1;
inline bool TarsInfo::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TarsInfo::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TarsInfo::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TarsInfo::clear_fd() {
  fd_ = 0u;
  clear_has_fd();
}
inline ::google::protobuf::uint32 TarsInfo::fd() const {
  // @@protoc_insertion_point(field_get:IM.RPC.TarsInfo.fd)
  return fd_;
}
inline void TarsInfo::set_fd(::google::protobuf::uint32 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.TarsInfo.fd)
}

// required uint32 uid = 2;
inline bool TarsInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TarsInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TarsInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TarsInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 TarsInfo::uid() const {
  // @@protoc_insertion_point(field_get:IM.RPC.TarsInfo.uid)
  return uid_;
}
inline void TarsInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.TarsInfo.uid)
}

// required uint32 request_id = 3;
inline bool TarsInfo::has_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TarsInfo::set_has_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TarsInfo::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TarsInfo::clear_request_id() {
  request_id_ = 0u;
  clear_has_request_id();
}
inline ::google::protobuf::uint32 TarsInfo::request_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.TarsInfo.request_id)
  return request_id_;
}
inline void TarsInfo::set_request_id(::google::protobuf::uint32 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.TarsInfo.request_id)
}

// required uint32 port = 4;
inline bool TarsInfo::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TarsInfo::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TarsInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TarsInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TarsInfo::port() const {
  // @@protoc_insertion_point(field_get:IM.RPC.TarsInfo.port)
  return port_;
}
inline void TarsInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.TarsInfo.port)
}

// required string ip = 5;
inline bool TarsInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TarsInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TarsInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TarsInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TarsInfo::ip() const {
  // @@protoc_insertion_point(field_get:IM.RPC.TarsInfo.ip)
  return *ip_;
}
inline void TarsInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.TarsInfo.ip)
}
inline void TarsInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.TarsInfo.ip)
}
inline void TarsInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.TarsInfo.ip)
}
inline ::std::string* TarsInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.TarsInfo.ip)
  return ip_;
}
inline ::std::string* TarsInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TarsInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.TarsInfo.ip)
}

// -------------------------------------------------------------------

// GroupIDName

// required uint32 group_id = 1;
inline bool GroupIDName::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupIDName::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupIDName::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupIDName::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupIDName::group_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupIDName.group_id)
  return group_id_;
}
inline void GroupIDName::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupIDName.group_id)
}

// required string group_name = 2;
inline bool GroupIDName::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupIDName::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupIDName::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupIDName::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupIDName::group_name() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupIDName.group_name)
  return *group_name_;
}
inline void GroupIDName::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.GroupIDName.group_name)
}
inline void GroupIDName::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.GroupIDName.group_name)
}
inline void GroupIDName::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.GroupIDName.group_name)
}
inline ::std::string* GroupIDName::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.GroupIDName.group_name)
  return group_name_;
}
inline ::std::string* GroupIDName::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupIDName::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.GroupIDName.group_name)
}

// -------------------------------------------------------------------

// CourseGroupInfo

// required uint32 group_id = 1;
inline bool CourseGroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CourseGroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CourseGroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CourseGroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 CourseGroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.CourseGroupInfo.group_id)
  return group_id_;
}
inline void CourseGroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.CourseGroupInfo.group_id)
}

// required string group_name = 2;
inline bool CourseGroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CourseGroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CourseGroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CourseGroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& CourseGroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.RPC.CourseGroupInfo.group_name)
  return *group_name_;
}
inline void CourseGroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.CourseGroupInfo.group_name)
}
inline void CourseGroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.CourseGroupInfo.group_name)
}
inline void CourseGroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.CourseGroupInfo.group_name)
}
inline ::std::string* CourseGroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.CourseGroupInfo.group_name)
  return group_name_;
}
inline ::std::string* CourseGroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CourseGroupInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.CourseGroupInfo.group_name)
}

// required string creator_name = 3;
inline bool CourseGroupInfo::has_creator_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CourseGroupInfo::set_has_creator_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CourseGroupInfo::clear_has_creator_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CourseGroupInfo::clear_creator_name() {
  if (creator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creator_name_->clear();
  }
  clear_has_creator_name();
}
inline const ::std::string& CourseGroupInfo::creator_name() const {
  // @@protoc_insertion_point(field_get:IM.RPC.CourseGroupInfo.creator_name)
  return *creator_name_;
}
inline void CourseGroupInfo::set_creator_name(const ::std::string& value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.CourseGroupInfo.creator_name)
}
inline void CourseGroupInfo::set_creator_name(const char* value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.CourseGroupInfo.creator_name)
}
inline void CourseGroupInfo::set_creator_name(const char* value, size_t size) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.CourseGroupInfo.creator_name)
}
inline ::std::string* CourseGroupInfo::mutable_creator_name() {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creator_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.CourseGroupInfo.creator_name)
  return creator_name_;
}
inline ::std::string* CourseGroupInfo::release_creator_name() {
  clear_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = creator_name_;
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CourseGroupInfo::set_allocated_creator_name(::std::string* creator_name) {
  if (creator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete creator_name_;
  }
  if (creator_name) {
    set_has_creator_name();
    creator_name_ = creator_name;
  } else {
    clear_has_creator_name();
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.CourseGroupInfo.creator_name)
}

// required uint32 identity = 4;
inline bool CourseGroupInfo::has_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CourseGroupInfo::set_has_identity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CourseGroupInfo::clear_has_identity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CourseGroupInfo::clear_identity() {
  identity_ = 0u;
  clear_has_identity();
}
inline ::google::protobuf::uint32 CourseGroupInfo::identity() const {
  // @@protoc_insertion_point(field_get:IM.RPC.CourseGroupInfo.identity)
  return identity_;
}
inline void CourseGroupInfo::set_identity(::google::protobuf::uint32 value) {
  set_has_identity();
  identity_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.CourseGroupInfo.identity)
}

// -------------------------------------------------------------------

// GroupMsgId

// required uint32 group_id = 1;
inline bool GroupMsgId::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgId::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgId::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgId::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupMsgId::group_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupMsgId.group_id)
  return group_id_;
}
inline void GroupMsgId::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupMsgId.group_id)
}

// required uint32 msg_id = 2;
inline bool GroupMsgId::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgId::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgId::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgId::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 GroupMsgId::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupMsgId.msg_id)
  return msg_id_;
}
inline void GroupMsgId::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupMsgId.msg_id)
}

// -------------------------------------------------------------------

// GroupMsgRes

// required uint32 group_id = 1;
inline bool GroupMsgRes::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgRes::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgRes::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgRes::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupMsgRes::group_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupMsgRes.group_id)
  return group_id_;
}
inline void GroupMsgRes::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupMsgRes.group_id)
}

// required uint32 msg_id = 2;
inline bool GroupMsgRes::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgRes::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgRes::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgRes::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 GroupMsgRes::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupMsgRes.msg_id)
  return msg_id_;
}
inline void GroupMsgRes::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupMsgRes.msg_id)
}

// required uint32 result = 3;
inline bool GroupMsgRes::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgRes::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgRes::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 GroupMsgRes::result() const {
  // @@protoc_insertion_point(field_get:IM.RPC.GroupMsgRes.result)
  return result_;
}
inline void GroupMsgRes::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.GroupMsgRes.result)
}

// -------------------------------------------------------------------

// IMRPCGetCourseGroupInfoReq

// required uint32 user_im_id = 1;
inline bool IMRPCGetCourseGroupInfoReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCGetCourseGroupInfoReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCGetCourseGroupInfoReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoReq.user_im_id)
  return user_im_id_;
}
inline void IMRPCGetCourseGroupInfoReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCGetCourseGroupInfoReq.user_im_id)
}

// required .IM.RPC.TarsInfo tars_info = 2;
inline bool IMRPCGetCourseGroupInfoReq::has_tars_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRPCGetCourseGroupInfoReq::set_has_tars_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCGetCourseGroupInfoReq::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoReq.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCGetCourseGroupInfoReq::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCGetCourseGroupInfoReq.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCGetCourseGroupInfoReq::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCGetCourseGroupInfoReq::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCGetCourseGroupInfoReq.tars_info)
}

// optional bytes attach_data = 20;
inline bool IMRPCGetCourseGroupInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCGetCourseGroupInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCGetCourseGroupInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCGetCourseGroupInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
  return *attach_data_;
}
inline void IMRPCGetCourseGroupInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
}
inline void IMRPCGetCourseGroupInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
}
inline void IMRPCGetCourseGroupInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
}
inline ::std::string* IMRPCGetCourseGroupInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCGetCourseGroupInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCGetCourseGroupInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCGetCourseGroupInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMRPCGetCourseGroupInfoRsp

// required uint32 user_im_id = 1;
inline bool IMRPCGetCourseGroupInfoRsp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCGetCourseGroupInfoRsp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCGetCourseGroupInfoRsp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoRsp.user_im_id)
  return user_im_id_;
}
inline void IMRPCGetCourseGroupInfoRsp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCGetCourseGroupInfoRsp.user_im_id)
}

// repeated .IM.RPC.CourseGroupInfo group_info_list = 2;
inline int IMRPCGetCourseGroupInfoRsp::group_info_list_size() const {
  return group_info_list_.size();
}
inline void IMRPCGetCourseGroupInfoRsp::clear_group_info_list() {
  group_info_list_.Clear();
}
inline const ::IM::RPC::CourseGroupInfo& IMRPCGetCourseGroupInfoRsp::group_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoRsp.group_info_list)
  return group_info_list_.Get(index);
}
inline ::IM::RPC::CourseGroupInfo* IMRPCGetCourseGroupInfoRsp::mutable_group_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCGetCourseGroupInfoRsp.group_info_list)
  return group_info_list_.Mutable(index);
}
inline ::IM::RPC::CourseGroupInfo* IMRPCGetCourseGroupInfoRsp::add_group_info_list() {
  // @@protoc_insertion_point(field_add:IM.RPC.IMRPCGetCourseGroupInfoRsp.group_info_list)
  return group_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::CourseGroupInfo >&
IMRPCGetCourseGroupInfoRsp::group_info_list() const {
  // @@protoc_insertion_point(field_list:IM.RPC.IMRPCGetCourseGroupInfoRsp.group_info_list)
  return group_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::CourseGroupInfo >*
IMRPCGetCourseGroupInfoRsp::mutable_group_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.RPC.IMRPCGetCourseGroupInfoRsp.group_info_list)
  return &group_info_list_;
}

// required .IM.RPC.TarsInfo tars_info = 3;
inline bool IMRPCGetCourseGroupInfoRsp::has_tars_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCGetCourseGroupInfoRsp::set_has_tars_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCGetCourseGroupInfoRsp::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoRsp.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCGetCourseGroupInfoRsp::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCGetCourseGroupInfoRsp.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCGetCourseGroupInfoRsp::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCGetCourseGroupInfoRsp::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCGetCourseGroupInfoRsp.tars_info)
}

// required uint32 result = 4;
inline bool IMRPCGetCourseGroupInfoRsp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCGetCourseGroupInfoRsp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMRPCGetCourseGroupInfoRsp::result() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoRsp.result)
  return result_;
}
inline void IMRPCGetCourseGroupInfoRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCGetCourseGroupInfoRsp.result)
}

// optional bytes attach_data = 20;
inline bool IMRPCGetCourseGroupInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRPCGetCourseGroupInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRPCGetCourseGroupInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCGetCourseGroupInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMRPCGetCourseGroupInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
}
inline void IMRPCGetCourseGroupInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
}
inline void IMRPCGetCourseGroupInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
}
inline ::std::string* IMRPCGetCourseGroupInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCGetCourseGroupInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCGetCourseGroupInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCGetCourseGroupInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRPCSendGroupMsgReq

// required uint32 user_im_id = 1;
inline bool IMRPCSendGroupMsgReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCSendGroupMsgReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCSendGroupMsgReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.user_im_id)
  return user_im_id_;
}
inline void IMRPCSendGroupMsgReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.user_im_id)
}

// required uint32 user_id = 2;
inline bool IMRPCSendGroupMsgReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRPCSendGroupMsgReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRPCSendGroupMsgReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.user_id)
  return user_id_;
}
inline void IMRPCSendGroupMsgReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.user_id)
}

// required string user_name = 3;
inline bool IMRPCSendGroupMsgReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCSendGroupMsgReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCSendGroupMsgReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& IMRPCSendGroupMsgReq::user_name() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.user_name)
  return *user_name_;
}
inline void IMRPCSendGroupMsgReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.user_name)
}
inline void IMRPCSendGroupMsgReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCSendGroupMsgReq.user_name)
}
inline void IMRPCSendGroupMsgReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCSendGroupMsgReq.user_name)
}
inline ::std::string* IMRPCSendGroupMsgReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgReq.user_name)
  return user_name_;
}
inline ::std::string* IMRPCSendGroupMsgReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCSendGroupMsgReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgReq.user_name)
}

// required string user_portrait = 4;
inline bool IMRPCSendGroupMsgReq::has_user_portrait() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_user_portrait() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCSendGroupMsgReq::clear_has_user_portrait() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCSendGroupMsgReq::clear_user_portrait() {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_->clear();
  }
  clear_has_user_portrait();
}
inline const ::std::string& IMRPCSendGroupMsgReq::user_portrait() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
  return *user_portrait_;
}
inline void IMRPCSendGroupMsgReq::set_user_portrait(const ::std::string& value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
}
inline void IMRPCSendGroupMsgReq::set_user_portrait(const char* value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
}
inline void IMRPCSendGroupMsgReq::set_user_portrait(const char* value, size_t size) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
}
inline ::std::string* IMRPCSendGroupMsgReq::mutable_user_portrait() {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
  return user_portrait_;
}
inline ::std::string* IMRPCSendGroupMsgReq::release_user_portrait() {
  clear_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_portrait_;
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCSendGroupMsgReq::set_allocated_user_portrait(::std::string* user_portrait) {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (user_portrait) {
    set_has_user_portrait();
    user_portrait_ = user_portrait;
  } else {
    clear_has_user_portrait();
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgReq.user_portrait)
}

// required uint32 msg_type = 5;
inline bool IMRPCSendGroupMsgReq::has_msg_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_msg_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRPCSendGroupMsgReq::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRPCSendGroupMsgReq::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgReq::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.msg_type)
  return msg_type_;
}
inline void IMRPCSendGroupMsgReq::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.msg_type)
}

// required bytes msg_data = 6;
inline bool IMRPCSendGroupMsgReq::has_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMRPCSendGroupMsgReq::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMRPCSendGroupMsgReq::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& IMRPCSendGroupMsgReq::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
  return *msg_data_;
}
inline void IMRPCSendGroupMsgReq::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
}
inline void IMRPCSendGroupMsgReq::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
}
inline void IMRPCSendGroupMsgReq::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
}
inline ::std::string* IMRPCSendGroupMsgReq::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
  return msg_data_;
}
inline ::std::string* IMRPCSendGroupMsgReq::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCSendGroupMsgReq::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgReq.msg_data)
}

// repeated uint32 group_id_list = 7;
inline int IMRPCSendGroupMsgReq::group_id_list_size() const {
  return group_id_list_.size();
}
inline void IMRPCSendGroupMsgReq::clear_group_id_list() {
  group_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgReq::group_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.group_id_list)
  return group_id_list_.Get(index);
}
inline void IMRPCSendGroupMsgReq::set_group_id_list(int index, ::google::protobuf::uint32 value) {
  group_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.group_id_list)
}
inline void IMRPCSendGroupMsgReq::add_group_id_list(::google::protobuf::uint32 value) {
  group_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.RPC.IMRPCSendGroupMsgReq.group_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMRPCSendGroupMsgReq::group_id_list() const {
  // @@protoc_insertion_point(field_list:IM.RPC.IMRPCSendGroupMsgReq.group_id_list)
  return group_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMRPCSendGroupMsgReq::mutable_group_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.RPC.IMRPCSendGroupMsgReq.group_id_list)
  return &group_id_list_;
}

// required .IM.RPC.TarsInfo tars_info = 8;
inline bool IMRPCSendGroupMsgReq::has_tars_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_tars_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMRPCSendGroupMsgReq::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMRPCSendGroupMsgReq::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCSendGroupMsgReq::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCSendGroupMsgReq::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgReq.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCSendGroupMsgReq::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCSendGroupMsgReq::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgReq.tars_info)
}

// optional bytes attach_data = 20;
inline bool IMRPCSendGroupMsgReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMRPCSendGroupMsgReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMRPCSendGroupMsgReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMRPCSendGroupMsgReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCSendGroupMsgReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
  return *attach_data_;
}
inline void IMRPCSendGroupMsgReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
}
inline void IMRPCSendGroupMsgReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
}
inline void IMRPCSendGroupMsgReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
}
inline ::std::string* IMRPCSendGroupMsgReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCSendGroupMsgReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCSendGroupMsgReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgReq.attach_data)
}

// -------------------------------------------------------------------

// IMRPCSendGroupMsgRsp

// required uint32 user_im_id = 1;
inline bool IMRPCSendGroupMsgRsp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCSendGroupMsgRsp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCSendGroupMsgRsp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCSendGroupMsgRsp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgRsp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgRsp.user_im_id)
  return user_im_id_;
}
inline void IMRPCSendGroupMsgRsp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgRsp.user_im_id)
}

// repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
inline int IMRPCSendGroupMsgRsp::group_msg_res_list_size() const {
  return group_msg_res_list_.size();
}
inline void IMRPCSendGroupMsgRsp::clear_group_msg_res_list() {
  group_msg_res_list_.Clear();
}
inline const ::IM::RPC::GroupMsgRes& IMRPCSendGroupMsgRsp::group_msg_res_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Get(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCSendGroupMsgRsp::mutable_group_msg_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Mutable(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCSendGroupMsgRsp::add_group_msg_res_list() {
  // @@protoc_insertion_point(field_add:IM.RPC.IMRPCSendGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
IMRPCSendGroupMsgRsp::group_msg_res_list() const {
  // @@protoc_insertion_point(field_list:IM.RPC.IMRPCSendGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
IMRPCSendGroupMsgRsp::mutable_group_msg_res_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.RPC.IMRPCSendGroupMsgRsp.group_msg_res_list)
  return &group_msg_res_list_;
}

// required .IM.RPC.TarsInfo tars_info = 3;
inline bool IMRPCSendGroupMsgRsp::has_tars_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCSendGroupMsgRsp::set_has_tars_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCSendGroupMsgRsp::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCSendGroupMsgRsp::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCSendGroupMsgRsp::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgRsp.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCSendGroupMsgRsp::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgRsp.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCSendGroupMsgRsp::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCSendGroupMsgRsp::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgRsp.tars_info)
}

// required uint32 result = 4;
inline bool IMRPCSendGroupMsgRsp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCSendGroupMsgRsp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCSendGroupMsgRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCSendGroupMsgRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMRPCSendGroupMsgRsp::result() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgRsp.result)
  return result_;
}
inline void IMRPCSendGroupMsgRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgRsp.result)
}

// optional bytes attach_data = 20;
inline bool IMRPCSendGroupMsgRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRPCSendGroupMsgRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRPCSendGroupMsgRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRPCSendGroupMsgRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCSendGroupMsgRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
  return *attach_data_;
}
inline void IMRPCSendGroupMsgRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
}
inline void IMRPCSendGroupMsgRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
}
inline void IMRPCSendGroupMsgRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
}
inline ::std::string* IMRPCSendGroupMsgRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCSendGroupMsgRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCSendGroupMsgRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCSendGroupMsgRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRPCDeleteGroupMsgReq

// required uint32 user_im_id = 1;
inline bool IMRPCDeleteGroupMsgReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCDeleteGroupMsgReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCDeleteGroupMsgReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCDeleteGroupMsgReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCDeleteGroupMsgReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgReq.user_im_id)
  return user_im_id_;
}
inline void IMRPCDeleteGroupMsgReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCDeleteGroupMsgReq.user_im_id)
}

// repeated .IM.RPC.GroupMsgId group_msg_id_list = 2;
inline int IMRPCDeleteGroupMsgReq::group_msg_id_list_size() const {
  return group_msg_id_list_.size();
}
inline void IMRPCDeleteGroupMsgReq::clear_group_msg_id_list() {
  group_msg_id_list_.Clear();
}
inline const ::IM::RPC::GroupMsgId& IMRPCDeleteGroupMsgReq::group_msg_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgReq.group_msg_id_list)
  return group_msg_id_list_.Get(index);
}
inline ::IM::RPC::GroupMsgId* IMRPCDeleteGroupMsgReq::mutable_group_msg_id_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgReq.group_msg_id_list)
  return group_msg_id_list_.Mutable(index);
}
inline ::IM::RPC::GroupMsgId* IMRPCDeleteGroupMsgReq::add_group_msg_id_list() {
  // @@protoc_insertion_point(field_add:IM.RPC.IMRPCDeleteGroupMsgReq.group_msg_id_list)
  return group_msg_id_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgId >&
IMRPCDeleteGroupMsgReq::group_msg_id_list() const {
  // @@protoc_insertion_point(field_list:IM.RPC.IMRPCDeleteGroupMsgReq.group_msg_id_list)
  return group_msg_id_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgId >*
IMRPCDeleteGroupMsgReq::mutable_group_msg_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.RPC.IMRPCDeleteGroupMsgReq.group_msg_id_list)
  return &group_msg_id_list_;
}

// required .IM.RPC.TarsInfo tars_info = 3;
inline bool IMRPCDeleteGroupMsgReq::has_tars_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCDeleteGroupMsgReq::set_has_tars_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCDeleteGroupMsgReq::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCDeleteGroupMsgReq::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCDeleteGroupMsgReq::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgReq.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCDeleteGroupMsgReq::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgReq.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCDeleteGroupMsgReq::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCDeleteGroupMsgReq::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCDeleteGroupMsgReq.tars_info)
}

// optional bytes attach_data = 20;
inline bool IMRPCDeleteGroupMsgReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCDeleteGroupMsgReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCDeleteGroupMsgReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCDeleteGroupMsgReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCDeleteGroupMsgReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
  return *attach_data_;
}
inline void IMRPCDeleteGroupMsgReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
}
inline void IMRPCDeleteGroupMsgReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
}
inline void IMRPCDeleteGroupMsgReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
}
inline ::std::string* IMRPCDeleteGroupMsgReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCDeleteGroupMsgReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCDeleteGroupMsgReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCDeleteGroupMsgReq.attach_data)
}

// -------------------------------------------------------------------

// IMRPCDeleteGroupMsgRsp

// required uint32 user_im_id = 1;
inline bool IMRPCDeleteGroupMsgRsp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCDeleteGroupMsgRsp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCDeleteGroupMsgRsp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgRsp.user_im_id)
  return user_im_id_;
}
inline void IMRPCDeleteGroupMsgRsp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCDeleteGroupMsgRsp.user_im_id)
}

// repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
inline int IMRPCDeleteGroupMsgRsp::group_msg_res_list_size() const {
  return group_msg_res_list_.size();
}
inline void IMRPCDeleteGroupMsgRsp::clear_group_msg_res_list() {
  group_msg_res_list_.Clear();
}
inline const ::IM::RPC::GroupMsgRes& IMRPCDeleteGroupMsgRsp::group_msg_res_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Get(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCDeleteGroupMsgRsp::mutable_group_msg_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Mutable(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCDeleteGroupMsgRsp::add_group_msg_res_list() {
  // @@protoc_insertion_point(field_add:IM.RPC.IMRPCDeleteGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
IMRPCDeleteGroupMsgRsp::group_msg_res_list() const {
  // @@protoc_insertion_point(field_list:IM.RPC.IMRPCDeleteGroupMsgRsp.group_msg_res_list)
  return group_msg_res_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
IMRPCDeleteGroupMsgRsp::mutable_group_msg_res_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.RPC.IMRPCDeleteGroupMsgRsp.group_msg_res_list)
  return &group_msg_res_list_;
}

// required .IM.RPC.TarsInfo tars_info = 3;
inline bool IMRPCDeleteGroupMsgRsp::has_tars_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCDeleteGroupMsgRsp::set_has_tars_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCDeleteGroupMsgRsp::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgRsp.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCDeleteGroupMsgRsp::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgRsp.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCDeleteGroupMsgRsp::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCDeleteGroupMsgRsp::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCDeleteGroupMsgRsp.tars_info)
}

// required uint32 result = 4;
inline bool IMRPCDeleteGroupMsgRsp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCDeleteGroupMsgRsp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMRPCDeleteGroupMsgRsp::result() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgRsp.result)
  return result_;
}
inline void IMRPCDeleteGroupMsgRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCDeleteGroupMsgRsp.result)
}

// optional bytes attach_data = 20;
inline bool IMRPCDeleteGroupMsgRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRPCDeleteGroupMsgRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRPCDeleteGroupMsgRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCDeleteGroupMsgRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
  return *attach_data_;
}
inline void IMRPCDeleteGroupMsgRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
}
inline void IMRPCDeleteGroupMsgRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
}
inline void IMRPCDeleteGroupMsgRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
}
inline ::std::string* IMRPCDeleteGroupMsgRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCDeleteGroupMsgRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCDeleteGroupMsgRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.RPC.IMRPCDeleteGroupMsgRsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RPC
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eRPC_2eproto__INCLUDED
